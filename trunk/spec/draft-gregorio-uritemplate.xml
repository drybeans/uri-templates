<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
 <!ENTITY rfc2119 SYSTEM 'bibxml/reference.RFC.2119.xml'>
 <!ENTITY rfc3986 SYSTEM 'bibxml/reference.RFC.3986.xml'>
 <!ENTITY rfc3987 SYSTEM 'bibxml/reference.RFC.3987.xml'>
 <!ENTITY rfc5234 SYSTEM 'bibxml/reference.RFC.5234.xml'>
 <!ENTITY rfc2978 SYSTEM 'bibxml/reference.RFC.2978.xml'>
 <!ENTITY rfc3629 SYSTEM 'bibxml/reference.RFC.3629.xml'>
 <!ENTITY ASCII   SYSTEM 'bibxml/_reference.ANSI.X3-4.1986.xml'>
 <!ENTITY UNIV4   SYSTEM 'bibxml/univ4.xml'>
 <!ENTITY UTR15   SYSTEM 'bibxml/utr15.xml'>
 ]>

<!--<?xml-stylesheet type='text/xsl' href='rfc2629.xslt'/ ?>-->

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="yes" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>
<?rfc comments="yes" ?>
<?rfc inline="yes" ?>
<?rfc tocdepth="3" ?>
<!--
 1. Update the docName
 2. Update the date
 3. Update the Revision History.
-->

<rfc category="std" ipr="full3978" docName="draft-gregorio-uritemplate-03">
 <front>
  <title>URI Template</title>

  <author initials='J.C.' surname="Gregorio" fullname='Joe Gregorio' role="editor">
   <organization>Google</organization>
   <address>
    <email>joe@bitworking.org</email>
    <uri>http://bitworking.org/</uri>
   </address>
  </author>

  <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
   <organization abbrev="Day Software">Day Software</organization>
   <address>
    <email>fielding@gbiv.com</email>
    <uri>http://roy.gbiv.com/</uri>
   </address>
  </author>

  <author initials='M.H.' surname="Hadley" fullname='Marc Hadley' role="editor">
   <organization>Sun Microsystems</organization>
   <address>
    <email>Marc.Hadley@sun.com</email>
    <uri>http://sun.com/</uri>
   </address>
  </author>

  <author initials='M.N.' surname="Nottingham" fullname='Mark Nottingham' role="editor">
   <organization></organization>
   <address>
    <email>mnot@pobox.com</email>
    <uri>http://mnot.net/</uri>
   </address>
  </author>

  <author initials='D.O.' surname="Orchard" fullname='David Orchard'>
   <organization>BEA Systems, Inc.</organization>
   <address>
    <email>dorchard@bea.com</email>
    <uri>http://bea.com/</uri>
   </address>
  </author>

  <date day="08" month="Jul" year="2009"/>
  <abstract>
   <t>
    A URI Template is a compact sequence of characters
    for describing a range of Uniform Resource Identifiers
    through variable substitution.
    This specification defines the URI Template
    syntax and the process for expanding a URI Template into a
    URI, along with guidelines for the
    use of URI Templates on the Internet.
   </t>
  </abstract>

  <note title="Editorial Note (to be removed by RFC Editor)">
   <t>
    To provide feedback on this Internet-Draft, join the
    <eref target="http://lists.w3.org/Archives/Public/uri/">W3C URI
    mailing list (http://lists.w3.org/Archives/Public/uri/)</eref>.
   </t>
  </note>
 </front>

 <middle>
  <section title="Introduction">
   <t>
    A Uniform Resource Identifier (URI) <xref target="RFC3986"/>
    is often used to identify a specific resource within a common
    space of similar resources. For example, personal web spaces
    are often delegated using a common pattern, such as
   </t>
   <figure><artwork>
  http://example.com/users/fred/
  http://example.com/users/mark/
   </artwork></figure>
   <t>
    or a set of dictionary entries might be grouped in a hierarchy
    by the first letter of the term, as in
   </t>
   <figure><artwork>
  http://example.com/dictionary/c/cat
  http://example.com/dictionary/d/dog
   </artwork></figure>
   <t>
    or a service interface might be invoked with various user input
    in a common pattern, as in
   </t>
   <figure><artwork>
  http://example.com/search?q=cat&amp;lang=en
  http://example.com/search?q=dog&amp;lang=fr
   </artwork></figure>
   <t>
    URI Templates provide a mechanism for abstracting a space of
    resource identifiers such that the variable parts can be easily
    identified and described.  URI templates can have many uses,
    including discovery of available services, configuring resource
    mappings, defining computed links, specifying interfaces, and
    other forms of programmatic interaction with resources.
    For example, the above resources could be described by the
    following URI templates:
   </t>
   <figure><artwork>
  http://example.com/users/{username}/
  http://example.com/dictionary/{term:1}/{term}
  http://example.com/search{?q,lang}
   </artwork></figure>
   <t>
    A URI Template provides both a structural description of a URI
    space and, when variable values are provided, a simple instruction
    on how to construct URIs corresponding to each of those values.
    A URI Template is transformed into a URI by replacing each
    delimited expression with its value as defined by the
    expression type and the values of variables named within the
    expression.  The expression types range from simple value
    substitution to multiple key=value lists.  The substitutions
    are based on the URI generic syntax, allowing an implementation
    to process any URI Template without knowing the scheme-specific
    requirements of every possible resulting URI.
   </t>
   <t>
    Since a URI Template describes a superset of the identifiers,
    there is no implication that every possible substitution for
    each delimited variable expression corresponds to a URI of an
    existing resource.  Our expectation is that an application
    constructing URIs according to the template will be provided
    with an appropriate set of values for the variables being
    substituted and will be able to cope with any errors that might
    occur should the resulting URI be inaccessible.
   </t>
   <t>
    URI Template expressions are not URIs: they do not identify
    an abstract or physical resource, they are not parsed as URIs,
    and should not be used in places where a URI would be expected
    unless the template expressions will be expanded by a template
    processor prior to use.  Distinct field, element, or attribute
    names should be used to differentiate protocol elements that
    carry a URI Template from those that expect a URI.
   </t>

   <section title="Overview">
    <t>
     A URI Template consists of a string of characters with zero or
     more embedded variable expressions, each expression being
     delimited by a matching pair of braces ('{', '}').
     Each expression contains an optional operator that indicates
     the expression type (defaulting to simple value substitution)
     and a list of one or more comma-separated variable names with
     optional modifiers.  The optional modifiers allow splitting the
     variable value into a substring (prefix or suffix), providing a
     default value for when the variable is empty, or indicating
     that the value be processed as a list or associative array
     of strings instead of a single string value.
    </t>
    <t>
     The process of URI Template expansion is to scan the
     reference string from left to right and replace each
     expression with the result of applying the operator to
     the values of each variable in the list.  The result of
     expanding all template expressions is a URI-reference,
     as defined by <xref target="RFC3986"/>.  The process is
     therefore similar to a macro language with a fixed set
     of macro definitions. For example, given the following
     URI Template:
    </t>
    <figure><artwork>
  http://www.example.com/users/{userid}
    </artwork></figure>
    <t>
     If the variable is assigned a value of
    </t>
    <figure><artwork>
  userid := "fred"
    </artwork></figure>
    <t>
     then the expansion of the URI Template will be:
    </t>
    <figure><artwork>
  http://www.example.com/users/fred
    </artwork></figure>
    <t>
     Here is an example that constructs a query
     from multiple variables:
    </t>
    <figure><artwork>
  http://www.example.com/foo{?query,number}
    </artwork></figure>
    <t>
     If the variables have the values
    </t>
    <figure><artwork>
  query  := "mycelium"
  number := 100
    </artwork></figure>
    <t>
     then the expansion of the URI Template is:
    </t>
    <figure><artwork>
  http://www.example.com/foo?query=mycelium&amp;number=100
    </artwork></figure>
    <t>
     Each template expression describes in a machine
     readable manner how the URI is to be constructed.
    </t>
    <figure><artwork>
  http://www.example.com/foo{?query,number}
                            \_____________/
                               |
                               |
                      Join 'var=value' for each variable
                      in ['query', 'number'] with '&amp;'.
    </artwork></figure>
    <t>
     The following table summarizes each type of template
     expression by its associated operator and cross-references
     the section of this document that defines the operator and
     its specific expansion process.  The example expansions are
     based on the following variables and values:
    </t>
    <figure><artwork>
   var   = "value";
   hello = "Hello World!";
   undef = null;
   empty = "";
   list  = [ "val1", "val2", "val3" ];
   keys  = [ "key1", "val1", "key2", "val2" ];
   path  = "/foo/bar"
   x     = "1024";
   y     = "768";

.-----------------------------------------------------------------.
| Sec | Op  | Description                                         |
|     |     |    Example Template       Expansion                 |
|-----+-----+-----------------------------------------------------|
| X.1 |     | Simple substitution with comma-separated values     |
|     |     |                                                     |
|     |     |    {var}                  value                     |
|     |     |    {hello}                Hello%20World%21          |
|     |     |    {path}/here            %2Ffoo%2Fbar/here         |
|     |     |    {x,y}                  1024,768                  |
|     |     |    {var=default}          value                     |
|     |     |    {undef=default}        default                   |
|     |     |                                                     |
|-----+-----+-----------------------------------------------------|
| X.2 |  +  | Reserved substitution with comma-separated values   |
|     |     |                                                     |
|     |     |    {+var}                 value                     |
|     |     |    {+hello}               Hello%20World!            |
|     |     |    {+path}/here           /foo/bar/here             |
|     |     |    {+path,x}/here         /foo/bar,1024/here        |
|     |     |    {+path}{x}/here        /foo/bar1024/here         |
|     |     |    {+empty}/here          /here                     |
|     |     |                                                     |
|-----+-----+-----------------------------------------------------|
| X.3 |  ;  | Encoded path segment parameters, semicolon-prefixed |
|     |     |                                                     |
|     |     |    {;x,y}                 ;x=1024;y=768             |
|     |     |    {;x,y,empty}           ;x=1024;y=768;empty       |
|     |     |    {;x,y,undef}           ;x=1024;y=768             |
|     |     |    {;%keys}               ;key1=val1;key2=val2      |
|     |     |                                                     |
|-----+-----+-----------------------------------------------------|
| X.4 |  ?  | Encoded query parameters, ampersand-separated       |
|     |     |                                                     |
|     |     |    {?x,y}                 ?x=1024&amp;y=768             |
|     |     |    {?x,y,empty}           ?x=1024&amp;y=768&amp;empty=      |
|     |     |    {?x,y,undef}           ?x=1024&amp;y=768             |
|     |     |    {?list}                ?list=val1,val2,val3      |
|     |     |    {?%keys}               ?key1=val1&amp;key2=val2      |
|     |     |    {?@list}  ?list=val1&amp;list2=val2&amp;list3=val3       |
|     |     |                                                     |
|-----+-----+-----------------------------------------------------|
| X.5 |  /  | Encoded path segments, slash-separated              |
|     |     |                                                     |
|     |     |    {/var}                 /value                    |
|     |     |    {/list}                /val1/val2/val3           |
|     |     |    {/list,x}              /val1/val2/val3/1024      |
|     |     |                                                     |
|-----+-----+-----------------------------------------------------|
    </artwork></figure>
    <t>
     I think the above covers all of the common cases without making
     the uncommon cases impossible.  The common case is that the delimiters
     (";", "?", and "/") are omitted when none of the listed variables are
     defined, which matches good URI practice.  Likewise, the substitution
     handler for ";" (path parameters) will omit the "=" when its value is empty,
     whereas the handler for "?" (form queries) will not omit the "=".
     Multiple variables and list values have their values joined with ","
     if there is no predefined joining mechanism for the operator.
    </t>
    <t>
     I think this mechanism is simple and readable when used with simple
     examples because the single-character operators match the URI generic
     syntax delimiters.  Only one operator inserts unencoded values; all
     of the others encode any characters other than unreserved.
    </t>
    <t>
     The mechanism does become harder to read when we do very unusual
     things and add all the bells and whistles, like
    </t>
    <figure><artwork>
{var,undef,empty,list}    value,,val1,val2,val3
{/var:3,undef,list,empty} /val/val1/val2/val3/
{;var,undef,empty,list}   ;var=value;empty;list=val1,val2,val3
{?var,undef,empty,list}   ?var=value&amp;empty=&amp;list=val1,val2,val3
{?var,undef,empty,@list}  ?var=value&amp;empty=&amp;list=val1&amp;list2=val2&amp;list3=val3
{?var,undef,empty,%keys}  ?var=value&amp;empty=&amp;key1=val1&amp;key2=val2&amp;key3=val3
    </artwork></figure>
    <t>
     but we don't need to care if complex cases are hard to read.
    </t>
   </section>

   <section title="Design Considerations">
    <t>
     The URI Template syntax has been designed to carefully balance
     the need for a powerful substitution mechanism with ease
     of implementation and security. The syntax is designed
     to be easy to parse while at the same time providing
     enough flexibility to express many common template
     scenarios.
    </t>
    <t>
     The most common cases for URI spaces can be described with
     simple URI Template expressions.  If we were only concerned with
     URI generation, then the template syntax could be limited
     to just simple substitution because the more complex forms could
     be generated by changing the variable definitions.  However, URI
     Templates have the additional goal of describing the layout of
     identifiers in terms of preexisting data values.  The template
     syntax must therefore include operators that can reflect how
     resource identifiers are commonly allocated.  Likewise, since
     prefix and suffix substrings are often used to partition large
     spaces of resources, modifiers on variable values provide a way
     to specify those substrings.
    </t>
    <t>
     Mechanisms similar to URI Templates have been defined within
     several specifications, including WSDL, WADL and OpenSearch.
     This specification extends and formally defines the syntax so
     that URI Templates can be used consistently across multiple
     Internet applications and within Internet message fields.
    </t>
   </section>

   <section title="Notational Conventions">
    <section title="Terminology">
     <t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
      "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",
      "MAY", and "OPTIONAL" in this document are to be
      interpreted as described in <xref target="RFC2119"/>.
     </t>
     <t>
      This specification uses the terms "character" and "coded
      character set" in accordance with the definitions provided
      in <xref target="RFC2978"/>, and "character encoding" in
      place of what
      <xref target="RFC2978"/> refers to as a "charset".
     </t>
     <t>
      In addition, the following terms are defined:
      <list style="symbols">
       <t>
        template expression - The text between '{' and '}', including the
        enclosing brackets.
       </t>
       <t>
        template expansion - The result of processing a template expression
        by replacing it with the variable values as defined by the
        expression type.
       </t>
       <t>
        template processor - A program or library that converts a URI
        Template into a URI.
       </t>
      </list>
     </t>
    </section>

    <section title="ABNF and Character Encoding">
     <t>
      This specification uses the Augmented Backus-Naur Form (ABNF)
      notation of <xref target="RFC5234"/>.  The following ABNF rules
      are imported from the normative references <xref target="RFC5234"/>,
      <xref target="RFC3986"/>, and <xref target="RFC3987"/>.
     </t>
     <figure><artwork type="abnf">
  ALPHA          =  %x41-5A / %x61-7A   ; A-Z / a-z
  DIGIT          =  %x30-39             ; 0-9
  
  unreserved     =  ALPHA / DIGIT / "-" / "." / "_" / "~"
  pct-encoded    =  "%" HEXDIG HEXDIG
      
  ucschar        =  %xA0-D7FF / %xF900-FDCF / %xFDF0-FFEF
                 /  %x10000-1FFFD / %x20000-2FFFD / %x30000-3FFFD
                 /  %x40000-4FFFD / %x50000-5FFFD / %x60000-6FFFD
                 /  %x70000-7FFFD / %x80000-8FFFD / %x90000-9FFFD
                 /  %xA0000-AFFFD / %xB0000-BFFFD / %xC0000-CFFFD
                 /  %xD0000-DFFFD / %xE1000-EFFFD

  iprivate       =  %xE000-F8FF / %xF0000-FFFFD / %x100000-10FFFD
     </artwork></figure>
     <t>
      A URI Template is defined as a sequence of characters and therefore
      has the same issues as URIs with regard to codepoints and character sets.
      That is, URI Template characters are frequently encoded as octets
      for transport or presentation.  This specification does not mandate
      any particular character encoding for mapping between URI Template
      characters and the octets used to store or transmit those characters.
      When a URI Template appears in a protocol element, the character
      encoding is defined by that protocol; without such a definition,
      a URI Template is assumed to be in the same character encoding as
      the surrounding text.
     </t>
     <t>
      The ABNF notation defines its terminal values to be
      non-negative integers (codepoints) that are a superset of the
      US-ASCII coded character set <xref target="ASCII"/>.  This
      specification defines terminal values as codepoints within the
      Unicode coded character set <xref target="UNIV4"/>.  Thus, a string
      of characters in a URI Template is assumed to be transformed into
      its corresponding sequence of Unicode codepoints prior to testing
      for a match with the URI Template grammar.
     </t>
    </section>
   </section>
  </section>

  <section title="URI Template Syntax">
   <t>
    A URI Template is a string of printable Unicode characters 
    that contains zero or more embedded template expressions.
   </t>
   <figure><artwork type="abnf">
  URI-Template  = *( literals / expression )
   </artwork></figure>

   <section title="Literals" anchor="literals">
    <t>
      The characters outside of expressions in a URI Template string
      are intended to be translated literally to the URI-reference.
      Characters allowed in the URI-reference grammar are copied to
      the result string. Characters not allowed in the URI-reference
      grammar MUST first be encoded using the UTF-8 character encoding,
      each octet of that encoding MUST then be pct-encoded, and the
      resulting sequence of pct-encoded octets is copied to the
      result string.
    </t>
    <figure><artwork type="abnf">
  literals      =  %x21 / %x23-24 / %x26 / %x28-3B / %x3D / %x3F-5B
                /  %x5D-5F / %x61-7A / %x7E / ucschar / iprivate
                /  pct-encoded
                     ; any Unicode character except:
                     ;  CTL, SP, DQUOTE, "'", "%" (aside from pct-encoded),
                     ;  "&lt;", "&gt;", "\", "^", "`", "{", "|", "}"
    </artwork></figure>
   </section>

   <section title="Expressions" anchor="expressions">
    <t>
     Template expressions are the parameterized components of a URI Template.
     Each expression either begins with an operator that defines the expansion
     process or defaults to simple variable substitution of unreserved values.
    </t>
    <figure><artwork type="abnf">
  expression    =  "{" [ operator ] variable-list "}"
  operator      =  "+" / "/" / ";" / "?" / op-reserve
  op-reserve    =  "|" / "!" / "*" / "~"
                       ; reserved for local use: "$" / "(" / ")"
    </artwork></figure>
    <t> 
     The operator characters have been chosen to reflect each of their roles
     as reserved characters in the URI generic syntax.  The operators defined
     by this specification include:
     plus ("+") for substituting values that may contain reserved characters;
     slash ("/") for substituting values as a sequence of path segments
     separated by "/";
     semicolon (";") for substituting key=value pairs as path parameters
     prefixed by ";"; and,
     question-mark ("?") for substituting a query component beginning
     with "?" and consisting of key=value pairs separated by "&amp;".
     These operators will be described in detail in <xref target="evaluating"/>.
    </t>
    <t>
     The operator characters pipe ("|"), exclamation ("!"), asterisk ("*"),
     and tilde ("~") are reserved for future extensions.  A URI Template
     processor that unexpectedly encounters such an extension operator
     should flag the expression as an error and include it in the result
     without expansion.
    </t>
    <t>
     The expression syntax specifically excludes use of the dollar ("$")
     and parentheses ["(" and ")"] characters so that they remain
     available for local language extensions outside the scope of this
     specification.
    </t>
   </section>

   <section title="Variables" anchor="variables">
    <t>
     After the operator (if any), each expression contains a list of
     one or more comma-separated variable specifiers (varspec).
     The variable names serve multiple purposes: documentation for
     what kinds of values are expected, identifiers for associating
     values within a URI Template processor, and the string to use
     for each key on key=value substitutions.
    </t>
    <figure><artwork type="abnf">
  variable-list =  varspec *( "," varspec )
  varspec       =  [ vartype ] varname [ modifier ] [ "=" default ]
  vartype       =  "@" / "%"
  varname       =  1*varchar
  varchar       =  ALPHA / DIGIT /"." / "_" / ucschar / iprivate
    </artwork></figure>
    <t>
     An optional variable type indicator MAY be supplied before each
     variable name to indicate that the variable's value should be
     processed as a list ("@") or an associative array ("%").  Note
     that these variable types are instructions to the template
     processor, not an indication of language or implementation type.
    </t>
    <t>
     An expression MAY reference variables that are unknown
     to the template processor or whose value is set to a special
     "undefined" value, such as undef or null.  Such undefined
     variables are given special treatment by the expansion process.
    </t>
    <t>
     A variable value that is a string of length zero is not considered
     undefined; it has the defined value of an empty string.  Likewise,
     a list or associative array variable that contains no members is
     considered defined, though its processing for some operators may
     be identical to that of an undefined variable.
    </t>
    <t>
     A variable may appear in more than one expression in a
     URI Template. The value of that variable MUST remain static
     throughout the template expansion process: if the same variable
     appears in more than one expression, then it must have the same
     value for the purpose of calculating each expansion.
    </t>
   </section>

   <section title="Value Modifiers" anchor="modifiers">
    <t>
     Any of the variables can have a modifier indicating that its
     value is limited to a prefix, suffix, or the remainder of
     a prefix or suffix of the variable value.  The primary use of
     these modifiers is to partition an identifier space hierarchically,
     as is often found in reference sites and hash-based storage.
     They can also be used to indicate the maximum length of a given
     substitution.
    </t>
    <figure><artwork type="abnf">
  modifier      =  ( substring / remainder ) offset
  substring     =  ":"
  remainder     =  "^"
  offset        =  [ from-end ] 1*DIGIT
  from-end      =  "-"
    </artwork></figure>
    <t>
     If the variable is not typed, then the offset refers to a
     maximum number of characters from either the beginning (prefix)
     or end (suffix) of the variable's value as a string.  A substring
     modifier requires that only the indicated prefix or suffix be
     used in the expansion.  A remainder modifier requires that only
     the remainder of the value, excluding the indicated prefix or
     suffix, be used in the expansion.  If the offset is greater than
     the length of the variable's value, then the entire string is used
     for a substring and the empty string is used for a remainder.
    </t>
    <t>
     If the variable is typed as a list, then the offset refers to
     a maximum number of members from the beginning or end of that list.
     A substring modifier on a list requires that only the indicated members
     be used in the expansion.  A remainder modifier on a list requires
     that only the remaining members, excluding those indicated by the
     offset from beginning or end, be used in the expansion.
    </t>
    <t>
     If the variable is typed as an associative array, then the offset
     refers to a maximum number of tuples from the beginning or end of
     that array. A substring modifier on an array requires that only the
     indicated tuples be used in the expansion.  A remainder modifier
     on an array requires that only the remaining tuples, excluding
     those indicated by the offset from beginning or end, be used in
     the expansion.
    </t>
    <t>
     The following examples illustrate how modifiers work with the
     different variable types.  More complex examples are provided
     in <xref target="examples"/>.
    </t>
    <figure><artwork>
  Given the variable assignments:
    var   := "value";
    name  := [ "Fred", "Wilma", "Pebbles" ];
    favs  := [ "color", "red", "volume", "high" ];

  Example Template     Expansion

    {var}              value
    {var:20}           value
    {var:3}            val
    {var^3}            ue
    {var:-3}           lue
    {var^-3}           va

    {?name}            ?name=Fred,Wilma,Pebbles
    {?name:1}          ?name=F
    {?@name}           ?name=Fred&amp;name2=Wilma&amp;name3=Pebbles
    {?@name:1}         ?name=Fred
    {?@name^1}         ?name2=Wilma&amp;name3=Pebbles
    
    {?favs}            ?favs=color,red,volume,high
    {?%favs}           ?color=red&amp;volume=high
    {?%favs:1}         ?color=red
    {?%favs^1}         ?volume=high
    {?%favs:-1}        ?volume=high
    {?%favs^-1}        ?color=red
    </artwork></figure>
   </section>

   <section title="Value Defaults" anchor="defaults">
    <t>
     Any of the variables may also be supplied with a default value
     to be used when a template processor determines the variable to be
     undefined. The default value is limited to the unreserved and
     percent-encoded characters of a URI-reference, since our intention
     is for the default to be presented in the exact form that it would
     appear in the resulting URI.  The default is not affected by the
     variable modifiers; it is assumed that the default string
     provided in the expression already reflects any necessary
     substring or remainder processing.
    </t>
    <figure><artwork type="abnf">
  default       =  *( unreserved / pct-encoded )
    </artwork></figure>
    <t>
     The following examples illustrate how default values work with the
     different variable types.  More complex examples are provided
     in <xref target="examples"/>.
    </t>
    <figure><artwork>
  Given the variable assignments:
    var   := "value";
    empty := "";
    undef := null;
    name  := [ "Fred", "Wilma", "Pebbles" ];
    favs  := [ "color", "red", "volume", "high" ];

  Example Template     Expansion

    {var=default}      value
    {undef=default}    default

    x{empty}y          xy
    x{empty=_}y        xy
    x{undef}y          xy
    x{undef=_}y        x_y

    x{?@name=none}     x?name=Fred&amp;name2=Wilma&amp;name3=Pebbles
    x{?@undef}         x
    x{?@undef=none}    x?undef=none
    x{?@empty}         x?empty=
    x{?@empty=none}    x?empty=
    
    x{?%favs=none}     x?color=red&amp;volume=high
    x{?%undef}         x
    x{?%undef=none}    x?undef=none
    x{?%empty}         x?empty=
    x{?%empty=none}    x?empty=
    </artwork></figure>
   </section>
  </section>

  <section title="URI Template Expansion" anchor="evaluating">
   <t>
    Template expansion is the process of turning
    a URI Template into a URI given definitions
    for the variables used in the template. Substitution
    replaces each expression with its calculated value.
    A template processor take two inputs, a URI Template and
    a set of variables, and returns a URI-reference.
   </t>
   <t>
    Before substitution the template processor MUST convert
    every variable value into a sequence of characters in
    ( unreserved / pct-encoded ).
    The template processor does that using the following algorithm:
    The template processor normalizes the string using NFKC, converts it to
    UTF-8 <xref target="RFC3629"/>, and then
    every octet of the UTF-8 string that falls outside of
    ( unreserved ) MUST be percent-encoded, as
    per <xref target="RFC3986"/>, section 2.1.
    For variables that are lists, the above algorithm is applied
    to each value in the list.
   </t>
   <t>
    The Unicode Standard <xref target="UNIV4"/> defines various
    equivalences between sequences of characters for various
    purposes.  Unicode Standard Annex #15 <xref target="UTR15"/> defines
    various Normalization Forms for these equivalences, in
    particular Normalization Form KC (NFKC, Compatibility
    Decomposition, followed by Canonical Composition). Since
    different Normalized Forms unicode strings will have
    different UTF-8 representations the only way to guarantee
    that template processors will produce the same URI is to
    require a common Normalized Form.
   </t>
   <t>
    Requiring that all characters outside of ( unreserved ) be
    percent encoded means that the only characters outside of
    ( unreserved ) that will appear in the generated URI-reference
    will come from outside the template expressions in the URI Template or
    from the argument of a template expression. This means that the
    designer of the URI Template determines the placement of reserved
    characters in the resulting URI, and thus the structure of the
    resulting generated URI-reference.
   </t>
   <t>
    If the expression is an operator then the substitution value
    is determined by the given operator. Each operator
    works only on the variables that are defined within
    their expression.
   </t>
   <t>
    The result of substitution
    MUST match the URI-reference rule and SHOULD also match
    any known rules for the scheme of the resulting URI.
   </t>
   <t>
    If a template processor encounters an operator that it does not
    understand then it MUST fail and MUST NOT produce a URI from
    the URI Template. The list of operators that a template processor
    knows is not constrained by this specification, that is, later
    specifications may add new operators.
   </t>
   <t>
    Every expression consists of either a variable ('var') or
    an operator expression ('operator'), and the rules for how
    to expand each of these is given below. For every expression
    a template MUST have at least one variable name in the
    template expression. It is an error if no variables are supplied.
    All of the variables supplied to a template expression MAY be undefined
    and the expansion rules below specify how to process the template
    expression in that situation.
   </t>
   <t>
    It is extremely easy to
    parse and perform the substitutions within a single pass loop.
   </t>

   <section title="('var') substitution" anchor="var">
    <t>
     In a variable ('var')
     expansion, if the variable is defined then
     substitute the value of the variable, otherwise
     substitute the default value. If no default value is
     given then substitute with the empty string.
    </t>
    <t>
     Example:
     <figure><artwork>
  foo := "fred"

  "{foo}"        -> "fred"
  "{bar=wilma}"  -> "wilma"
  "{baz}"        -> ""
     </artwork></figure>
    </t>
   </section>

   <section title="The 'opt' operator" anchor="opt">
    <t>
     If each variable is undefined or an empty list
     then substitute the empty string, otherwise
     substitute the value of 'arg'.
    </t>
    <t>
     Example:
     <figure><artwork>
  foo := "fred"

  "{-opt|fred@example.org|foo}" -> "fred@example.org"
  "{-opt|fred@example.org|bar}" -> ""
     </artwork></figure>
    </t>
   </section>

   <section title="The 'neg' operator" anchor="neg">
    <t>
     If each variable is undefined or an empty list
     then substitute the value of arg, otherwise
     substitute the empty string.
    </t>
    <t>
     Example:
     <figure><artwork>
  foo := "fred"

  "{-neg|fred@example.org|foo}" -> ""
  "{-neg|fred@example.org|bar}" -> "fred@example.org"
     </artwork></figure>
    </t>
   </section>

   <section title="The 'prefix' operator" anchor="prefix">
    <t>
     The prefix operator MUST only have one variable in
     its expression. More than one variable is an error condition.
     If the variable is undefined or an empty
     list then substitute the empty string. If the variable
     is a defined non-list then substitute the value of arg preceded
     by the value of the variable. If the variable is a defined list
     then substitute the concatenation of every list value preceded
     by the arg.
    </t>
    <t>
     Example:
     <figure><artwork>
  foo := "fred"
  bar := ["fee", "fi", "fo", "fum"]
  baz := []

  "{-prefix|/|foo}" -> "/fred"
  "{-prefix|/|bar}" -> "/fee/fi/fo/fum"
  "{-prefix|/|baz}" -> ""
  "{-prefix|/|qux}" -> ""
     </artwork></figure>
    </t>
   </section>

   <section title="The 'suffix' operator" anchor="append">
    <t>
     The prefix operator MUST only have one variable in
     its expression. More than one variable is an error condition.
     If the variable is undefined or an empty
     list then substitute the empty string. If the variable
     is a defined non-list then substitute the value of arg followed
     by the value of the variable. If the variable is a defined list
     then substitute the concatenation of every list value followed
     by the arg.
    </t>

    <t>
     Example:
     <figure><artwork>
  foo := "fred"
  bar := ["fee", "fi", "fo", "fum"]
  baz := []

  "{-suffix|/|foo}" -> "fred/"
  "{-suffix|/|bar}" -> "fee/fi/fo/fum/"
  "{-suffix|/|baz}" -> ""
  "{-suffix|/|qux}" -> ""
     </artwork></figure>
    </t>
   </section>

   <section title="The 'join' operator" anchor="join">
    <t>
     Supplying a list variable to the join operator
     is an error. For each variable that is defined and non-empty
     create a key=value string that is the concatenation
     of the variable name, "=", and the
     variable value. Concatenate more than one key=value
     string with intervening values of arg to
     create the substitution value. The order of variables
     MUST be preserved during substitution.
    </t>
    <t>
     Example:
     <figure><artwork>
  foo := "fred"
  bar := "barney"
  baz := ""

  "{-join|&amp;|foo,bar,baz,qux}" -> "foo=fred&amp;bar=barney&amp;baz="
  "{-join|&amp;|bar}" -> "bar=barney"
  "{-join|&amp;|qux}" -> ""
     </artwork></figure>
    </t>
   </section>

   <section title="The 'list' operator" anchor="list">
    <t>
     The listjoin operator MUST have only one variable
     in its expression and that variable must be a list.
     More than one variable is an error.
     If the list is non-empty then substitute
     the concatenation of all the list members with intervening
     values of arg. If the list is empty or the variable is undefined them
     substitute the empty string.
    </t>
    <t>
     Example:
     <figure><artwork>
  foo := ["fred", "barney", "wilma"]
  bar := ["a", "", "c"]
  baz := ["betty"]
  qux := []

  "{-list|/|foo}" -> "fred/barney/wilma"
  "{-list|/|bar}" -> "a//c"
  "{-list|/|baz}" -> "betty"
  "{-list|/|qux}" -> ""
  "{-list|/|corge}" -> ""
     </artwork></figure>
    </t>
   </section>
  </section>

  <section title="Error Handling" anchor="error">
   <t>
    During template substitution error conditions may arise.
    The exact circumstances for those errors are described in
    <xref target="evaluating"/>. When an error occurs the
    template processor MUST NOT return a URI. It is language
    specific and beyond the scope of this document how the
    template processor signals that an error has occurred and that
    a URI will not be generated from the template.
   </t>
  </section>

  <section title="Examples" anchor="examples">
   <texttable anchor="example-table">
    <preamble>
     Given the following template variable names and values:
    </preamble>
    <ttcol>Name</ttcol>  <ttcol>Value</ttcol>
    <c>foo</c>     <c>\u03d3</c>
    <c>bar</c>     <c>fred</c>
    <c>baz</c>     <c>10,20,30</c>
    <c>qux</c>     <c>["10","20","30"]</c>
    <c>corge</c>     <c>[]</c>
    <c>grault</c>     <c></c>
    <c>garply</c>     <c>a/b/c</c>
    <c>waldo</c>     <c>ben &amp; jerrys</c>
    <c>fred</c>     <c>["fred", "", "wilma"]</c>
    <c>plugh</c>    <c>["\u017F\u0307", "\u0073\u0307"]</c>
    <c>1-a_b.c</c>  <c>200</c>
   </texttable>
   <t>
    The variable 'foo' is the unicode character
    GREEK UPSILON WITH ACUTE AND HOOK SYMBOL.
    This character was chosen because it is one of only three characters
    that has a different normal form for each of the four normalization
    forms (NFC, NFD, NFKC, NFKD).
    The name 'xyzzy' has not been defined,
    the value of 'grault' is the empty string.
    The variables qux, corge, fred, and plugh are lists.
   </t>

   <t>The following URI Templates will be expanded as shown:</t>
   <t>    ----</t>
   <figure><artwork>
  http://example.org/?q={bar}
  http://example.org/?q=fred

  /{xyzzy}
  /

  http://example.org/?{-join|&amp;|foo,bar,xyzzy,baz}
  http://example.org/?foo=%CE%8E&amp;bar=fred&amp;baz=10%2C20%2C30

  http://example.org/?d={-list|,|qux}
  http://example.org/?d=10,20,30

  http://example.org/?d={-list|&amp;d=|qux}
  http://example.org/?d=10&amp;d=20&amp;d=30

  http://example.org/{bar}{bar}/{garply}
  http://example.org/fredfred/a%2Fb%2Fc

  http://example.org/{bar}{-prefix|/|fred}
  http://example.org/fred/fred//wilma

  {-neg|:|corge}{-suffix|:|plugh}
  :%E1%B9%A1:%E1%B9%A1:

  ../{waldo}/
  ../ben%20%26%20jerrys/

  telnet:192.0.2.16{-opt|:80|grault}
  telnet:192.0.2.16:80

  :{1-a_b.c}:
  :200:
   </artwork></figure>
   <t>    ----</t>
  </section>

  <section title="Security Considerations">
   <t>
    A URI Template does not contain active or executable content. Other
    security considerations are the same as those for URIs, see section 7
    of <xref target="RFC3986"/>.
   </t>
  </section>

  <section title="IANA Considerations" anchor="iana">
   <t>
    No IANA actions are required by this document.
   </t>
  </section>

  <section title="Acknowledgments" anchor="ack">
   <t>
    The following people made significant contributions to this
    specification: Michaeljohn Clement, DeWitt Clinton, John Cowan,
    James H. Manger, and James Snell.
   </t>
  </section>
 </middle>

 <back>
  <references title='Normative References'>
   &ASCII;
   &UNIV4;
   &UTR15;
   &rfc2119;
   &rfc2978;
   &rfc3986;
   &rfc3987;
   &rfc3629;
   &rfc5234;
  </references>

  <section title="Example URI Template Parser" anchor="parser">
   <t>
    Parsing a valid URI Template expression does not require
    building a parser from the given ABNF. Instead, the set of allowed
    characters in each part of URI Template expression has been
    chosen to avoid complex parsing, and breaking an expression into
    its component parts can be achieved by a series of splits
    of the character string.
   </t>
   <t>
    Here is example Python code that parses a URI Template
    expression and returns the operator, argument, and
    variables as a tuple. The variables are returned
    as a dictionary of variable names mapped to their
    default values. If no default is given then the
    name maps to None.
   </t>
   <figure><artwork>
  def parse_expression(expression):
      if "|" in expression:
          (op, arg, vars_) = expression.split("|")
          op = op[1:]
      else:
          (op, arg, vars_) = (None, None, expression)
      vars_ = vars_.split(",")

      variables = {}
      for var in vars_:
          if "=" in var:
              (varname, vardefault) = var.split("=")
          else:
              (varname, vardefault) = (var, None)
          variables[varname] = vardefault

      return (op, arg, variables)
   </artwork></figure>
   <t>
    And here is an example of the parse_expression() function being
    used.
   </t>
   <figure><artwork>
  &gt;&gt;&gt; parse_expression("-join|&amp;|a,b,c=1")
  ('join', '&amp;', {'a': None, 'c': '1', 'b': None})
  &gt;&gt;&gt; parse_expression("c=1")
  (None, None, {'c': '1'})
   </artwork></figure>
  </section>

  <section title="Revision History (to be removed by RFC Editor)" anchor="revisions">
   <t>04 - Changed the operator syntax to a single character that is
      analogous to its reserved role within the URI generic syntax,
      resulting in templates that are far more readable for the common
      cases. Replaced use of "expansion" with "expression", since expansion
      is traditionally used to refer to the result after expanding
      a macro (not the macro itself). Made applicable to any hypertext
      reference string, such that the process for template expansion
      also includes transforming the surrounding string into a proper
      URI-reference rather than assuming it is already in absolute URI form.
      Rewrote the text accordingly.</t>
   <t>03 - Added more examples. Introduced error conditions and defined
      their handling. Changed listjoin to list. Changed -append to -suffix,
      and allowed -prefix and -suffix to accept list variables. Clarified
      the handling of unicode.</t>
   <t>02 - Added operators and came up with coherent
      percent-encoding and reserved character story.
      Added large examples section which is extracted
      and tested against the implementation.
   </t>
   <t>01
   </t>
   <t>00 - Initial Revision.
   </t>
  </section>
 </back>
</rfc>
